functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents)
# Replace the local structure scoring function with its cached version
functLogLocalStructureScore <- function(node, parents, vOrder) {
scoreList$getFamilyScore(node, parents)
}
# Local order score i.e term of node in log P(D | <)
pruningDiff <- exp(7) # max difference between log(bestFamilyScore) - log(familyScore)
functLogLocalOrderScore <- function(node, vOrder) {
getLogSumOfExponentials( scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)$scores )
}
# Score of best order
logScoreBestOrder <- sum(getLogLocalOrderScores(1:numNodes, functLogLocalOrderScore))
# order-MCMC
numSamples <- 5000
system.time(result <- runOrderMCMC(numNodes, maxParents, functLogLocalStructureScore, numSamples))
plot(rowSums(result$logScores), type="l")
# Compute edge probabilities
sampleIdx <- seq(from=1000, to=numSamples, by=100)
samples <- result$samples[sampleIdx,]
sampleLogScores <- result$logScores[sampleIdx,]
mEdgeProb <- getEdgeProbabilities(samples, maxParents, functLogLocalStructureScore, sampleLogScores)
# Plot ROC curve
roc <- getRocCurve(mEdgeProb, mAdj)
xy <- matrix(c(0,1,0,1), 2, 2)
plot(roc, type="l", xlim=c(0,1), ylim=c(0,1), col="blue")
lines(xy, col="red")
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
# Local structure score function log(score(Xi, Pa(Xi) | D, <))
functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
system.time(scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents))
# Replace the local structure scoring function with its cached version
functLogLocalStructureScore <- function(node, parents, vOrder) {
scoreList$getFamilyScore(node, parents)
}
# Local order score i.e term of node in log P(D | <)
pruningDiff <- exp(7) # max difference between log(bestFamilyScore) - log(familyScore)
functLogLocalOrderScore <- function(node, vOrder) {
getLogSumOfExponentials( scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)$scores )
}
# Score of best order
logScoreBestOrder <- sum(getLogLocalOrderScores(1:numNodes, functLogLocalOrderScore))
# order-MCMC
numSamples <- 5000
system.time(result <- runOrderMCMC(numNodes, maxParents, functLogLocalOrderScore, numSamples))
plot(rowSums(result$logScores), type="l")
# Compute edge probabilities
sampleIdx <- seq(from=1000, to=numSamples, by=100)
samples <- result$samples[sampleIdx,]
sampleLogScores <- result$logScores[sampleIdx,]
mEdgeProb <- getEdgeProbabilities(samples, maxParents, functLogLocalStructureScore, sampleLogScores)
# Plot ROC curve
roc <- getRocCurve(mEdgeProb, mAdj)
xy <- matrix(c(0,1,0,1), 2, 2)
plot(roc, type="l", xlim=c(0,1), ylim=c(0,1), col="blue")
lines(xy, col="red")
source('~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/functions/order_mcmc.R')
source('~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/functions/scoring_functions.R')
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
# Local structure score function log(score(Xi, Pa(Xi) | D, <))
functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
system.time(scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents))
# Replace the local structure scoring function with its cached version
functLogLocalStructureScore <- function(node, parents, vOrder) {
scoreList$getFamilyScore(node, parents)
}
# Local order score i.e term of node in log P(D | <)
pruningDiff <- exp(7) # max difference between log(bestFamilyScore) - log(familyScore)
functLogLocalOrderScore <- function(node, vOrder) {
getLogSumOfExponentials( scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)$scores )
}
# Score of best order
logScoreBestOrder <- sum(getLogLocalOrderScores(1:numNodes, functLogLocalOrderScore))
# order-MCMC
numSamples <- 5000
system.time(result <- runOrderMCMC(numNodes, maxParents, functLogLocalOrderScore, numSamples))
plot(rowSums(result$logScores), type="l")
# Compute edge probabilities
sampleIdx <- seq(from=1000, to=numSamples, by=100)
samples <- result$samples[sampleIdx,]
sampleLogScores <- result$logScores[sampleIdx,]
mEdgeProb <- getEdgeProbabilities(samples, maxParents, functLogLocalStructureScore, sampleLogScores)
# Plot ROC curve
roc <- getRocCurve(mEdgeProb, mAdj)
xy <- matrix(c(0,1,0,1), 2, 2)
plot(roc, type="l", xlim=c(0,1), ylim=c(0,1), col="blue")
lines(xy, col="red")
functNodeStateProb <- createStateProbabilityFunction(cardinalities, mObs, functSuffStats=functSuffStats)
system.time({
vEstimatedObsProbs <- getStateVectorProbability(mUniqueObs, samples, maxParents, functNodeStateProb, functLogLocalStructureScore, sampleLogScores)
})
getKLDivergence(vObsProbs, vEstimatedObsProbs)
source('~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/functions/node_state_probabilities.R')
source('~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/functions/node_state_probabilities.R')
functNodeStateProb <- createStateProbabilityFunction(cardinalities, mObs, functSuffStats=functSuffStats)
system.time({
vEstimatedObsProbs <- getStateVectorProbability(mUniqueObs, samples, maxParents, functNodeStateProb, functLogLocalStructureScore, sampleLogScores)
})
getKLDivergence(vObsProbs, vEstimatedObsProbs)
functNodeStateProb <- createStateProbabilityFunction(cardinalities, mObs, functSuffStats=functSuffStats)
system.time({
vEstimatedObsProbs <- getStateVectorProbability(mUniqueObs, samples, maxParents, functNodeStateProb, scoreList$getFamiliesAndScores)
})
getKLDivergence(vObsProbs, vEstimatedObsProbs)
source('~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/functions/scoring_functions.R')
functNodeStateProb <- createStateProbabilityFunction(cardinalities, mObs, functSuffStats=functSuffStats)
system.time({
vEstimatedObsProbs <- getStateVectorProbability(mUniqueObs, samples, maxParents, functNodeStateProb, scoreList$getFamiliesAndScores)
})
getKLDivergence(vObsProbs, vEstimatedObsProbs)
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
# Local structure score function log(score(Xi, Pa(Xi) | D, <))
functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
system.time(scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents))
# Replace the local structure scoring function with its cached version
functLogLocalStructureScore <- function(node, parents, vOrder) {
scoreList$getFamilyScore(node, parents)
}
# Local order score i.e term of node in log P(D | <)
pruningDiff <- exp(7) # max difference between log(bestFamilyScore) - log(familyScore)
functLogLocalOrderScore <- function(node, vOrder) {
getLogSumOfExponentials( scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)$scores )
}
# Score of best order
logScoreBestOrder <- sum(getLogLocalOrderScores(1:numNodes, functLogLocalOrderScore))
# order-MCMC
numSamples <- 5000
system.time(result <- runOrderMCMC(numNodes, maxParents, functLogLocalOrderScore, numSamples))
plot(rowSums(result$logScores), type="l")
# Compute edge probabilities
sampleIdx <- seq(from=1000, to=numSamples, by=100)
samples <- result$samples[sampleIdx,]
sampleLogScores <- result$logScores[sampleIdx,]
mEdgeProb <- getEdgeProbabilities(samples, maxParents, functLogLocalStructureScore, sampleLogScores)
# Plot ROC curve
roc <- getRocCurve(mEdgeProb, mAdj)
xy <- matrix(c(0,1,0,1), 2, 2)
plot(roc, type="l", xlim=c(0,1), ylim=c(0,1), col="blue")
lines(xy, col="red")
functNodeStateProb <- createStateProbabilityFunction(cardinalities, mObs, functSuffStats=functSuffStats)
system.time({
vEstimatedObsProbs <- getStateVectorProbability(mUniqueObs, samples, maxParents, functNodeStateProb, scoreList$getFamiliesAndScores)
})
getKLDivergence(vObsProbs, vEstimatedObsProbs)
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
# Local structure score function log(score(Xi, Pa(Xi) | D, <))
functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
system.time(scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents))
# Replace the local structure scoring function with its cached version
functLogLocalStructureScore <- function(node, parents, vOrder) {
scoreList$getFamilyScore(node, parents)
}
# Local order score i.e term of node in log P(D | <)
pruningDiff <- 7 # best family consistent with an order exp(7) times more probable than worst included in computation
functLogLocalOrderScore <- function(node, vOrder) {
getLogSumOfExponentials( scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)$scores )
}
# Score of best order
logScoreBestOrder <- sum(getLogLocalOrderScores(1:numNodes, functLogLocalOrderScore))
# order-MCMC
numSamples <- 5000
system.time(result <- runOrderMCMC(numNodes, maxParents, functLogLocalOrderScore, numSamples))
source('~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/functions/scoring_functions.R')
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
# Local structure score function log(score(Xi, Pa(Xi) | D, <))
functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
system.time(scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents))
# Replace the local structure scoring function with its cached version
functLogLocalStructureScore <- function(node, parents, vOrder) {
scoreList$getFamilyScore(node, parents)
}
# Local order score i.e term of node in log P(D | <)
pruningDiff <- 7 # best family consistent with an order exp(7) times more probable than worst included in computation
functLogLocalOrderScore <- function(node, vOrder) {
getLogSumOfExponentials( scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)$scores )
}
# Score of best order
logScoreBestOrder <- sum(getLogLocalOrderScores(1:numNodes, functLogLocalOrderScore))
# order-MCMC
numSamples <- 5000
system.time(result <- runOrderMCMC(numNodes, maxParents, functLogLocalOrderScore, numSamples))
plot(rowSums(result$logScores), type="l")
# Compute edge probabilities
sampleIdx <- seq(from=1000, to=numSamples, by=100)
samples <- result$samples[sampleIdx,]
sampleLogScores <- result$logScores[sampleIdx,]
mEdgeProb <- getEdgeProbabilities(samples, maxParents, functLogLocalStructureScore, sampleLogScores)
# Plot ROC curve
roc <- getRocCurve(mEdgeProb, mAdj)
xy <- matrix(c(0,1,0,1), 2, 2)
plot(roc, type="l", xlim=c(0,1), ylim=c(0,1), col="blue")
lines(xy, col="red")
functNodeStateProb <- createStateProbabilityFunction(cardinalities, mObs, functSuffStats=functSuffStats)
functFamiliesAndLogStructureScores <- function(node, vOrder) {
scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)
}
system.time({
vEstimatedObsProbs <- getStateVectorProbability(mUniqueObs, samples, maxParents, functNodeStateProb, functFamiliesAndLogStructureScores)
})
getKLDivergence(vObsProbs, vEstimatedObsProbs)
library("gtools")
library("hash")
library("R.utils")
library("rbenchmark")
library("testthat")
sourceDir <- "~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/functions"
sourceDirectory(sourceDir)
numNodes <- 10
cardinalities <- rep(3, numNodes)
maxParents <- 3
mAdj <- generateRandomDag(numNodes, maxParents)
arrThetas <- generateMultinomialParams(mAdj, cardinalities)
mObs <- generateSamplesFromModel(mAdj, arrThetas, 500)
mUniqueObs <- unique.data.frame(mObs)
mUniqueObs <- as.matrix(mUniqueObs)
vObsProbs <- computeObsProbs(mAdj, arrThetas, mUniqueObs)
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
# Local structure score function log(score(Xi, Pa(Xi) | D, <))
functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
system.time(scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents))
# Replace the local structure scoring function with its cached version
functLogLocalStructureScore <- function(node, parents, vOrder) {
scoreList$getFamilyScore(node, parents)
}
# Local order score i.e term of node in log P(D | <)
pruningDiff <- 7 # best family consistent with an order exp(7) times more probable than worst included in computation
functLogLocalOrderScore <- function(node, vOrder) {
getLogSumOfExponentials( scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)$scores )
}
# Score of best order
logScoreBestOrder <- sum(getLogLocalOrderScores(1:numNodes, functLogLocalOrderScore))
# order-MCMC
numSamples <- 5000
system.time(result <- runOrderMCMC(numNodes, maxParents, functLogLocalOrderScore, numSamples))
plot(rowSums(result$logScores), type="l")
# Compute edge probabilities
sampleIdx <- seq(from=1000, to=numSamples, by=100)
samples <- result$samples[sampleIdx,]
sampleLogScores <- result$logScores[sampleIdx,]
mEdgeProb <- getEdgeProbabilities(samples, maxParents, functLogLocalStructureScore, sampleLogScores)
# Plot ROC curve
roc <- getRocCurve(mEdgeProb, mAdj)
xy <- matrix(c(0,1,0,1), 2, 2)
plot(roc, type="l", xlim=c(0,1), ylim=c(0,1), col="blue")
lines(xy, col="red")
functNodeStateProb <- createStateProbabilityFunction(cardinalities, mObs, functSuffStats=functSuffStats)
functFamiliesAndLogStructureScores <- function(node, vOrder) {
scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)
}
system.time({
vEstimatedObsProbs <- getStateVectorProbability(mUniqueObs, samples, maxParents, functNodeStateProb, functFamiliesAndLogStructureScores)
})
getKLDivergence(vObsProbs, vEstimatedObsProbs)
exp(6)
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
# Local structure score function log(score(Xi, Pa(Xi) | D, <))
functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
system.time(scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents))
# Replace the local structure scoring function with its cached version
functLogLocalStructureScore <- function(node, parents, vOrder) {
scoreList$getFamilyScore(node, parents)
}
# Local order score i.e term of node in log P(D | <)
pruningDiff <- 6 # best family consistent with an order exp(7) times more probable than worst included in computation
functLogLocalOrderScore <- function(node, vOrder) {
getLogSumOfExponentials( scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)$scores )
}
# Score of best order
logScoreBestOrder <- sum(getLogLocalOrderScores(1:numNodes, functLogLocalOrderScore))
# order-MCMC
numSamples <- 5000
system.time(result <- runOrderMCMC(numNodes, maxParents, functLogLocalOrderScore, numSamples))
plot(rowSums(result$logScores), type="l")
# Compute edge probabilities
sampleIdx <- seq(from=1000, to=numSamples, by=100)
samples <- result$samples[sampleIdx,]
sampleLogScores <- result$logScores[sampleIdx,]
mEdgeProb <- getEdgeProbabilities(samples, maxParents, functLogLocalStructureScore, sampleLogScores)
# Plot ROC curve
roc <- getRocCurve(mEdgeProb, mAdj)
xy <- matrix(c(0,1,0,1), 2, 2)
plot(roc, type="l", xlim=c(0,1), ylim=c(0,1), col="blue")
lines(xy, col="red")
functNodeStateProb <- createStateProbabilityFunction(cardinalities, mObs, functSuffStats=functSuffStats)
functFamiliesAndLogStructureScores <- function(node, vOrder) {
scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)
}
system.time({
vEstimatedObsProbs <- getStateVectorProbability(mUniqueObs, samples, maxParents, functNodeStateProb, functFamiliesAndLogStructureScores)
})
getKLDivergence(vObsProbs, vEstimatedObsProbs)
10/120
numNodes <- 10
cardinalities <- rep(3, numNodes)
maxParents <- 3
mAdj <- generateRandomDag(numNodes, maxParents)
arrThetas <- generateMultinomialParams(mAdj, cardinalities)
mObs <- generateSamplesFromModel(mAdj, arrThetas, 500)
mUniqueObs <- unique.data.frame(mObs)
mUniqueObs <- as.matrix(mUniqueObs)
vObsProbs <- computeObsProbs(mAdj, arrThetas, mUniqueObs)
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
# Local structure score function log(score(Xi, Pa(Xi) | D, <))
functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
system.time(scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents))
# Replace the local structure scoring function with its cached version
functLogLocalStructureScore <- function(node, parents, vOrder) {
scoreList$getFamilyScore(node, parents)
}
# Local order score i.e term of node in log P(D | <)
pruningDiff <- 7 # best family consistent with an order exp(7) times more probable than worst included in computations
functLogLocalOrderScore <- function(node, vOrder) {
getLogSumOfExponentials( scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)$scores )
}
# Score of best order
logScoreBestOrder <- sum(getLogLocalOrderScores(1:numNodes, functLogLocalOrderScore))
# order-MCMC
numSamples <- 5000
system.time(result <- runOrderMCMC(numNodes, maxParents, functLogLocalOrderScore, numSamples))
plot(rowSums(result$logScores), type="l")
# Compute edge probabilities
sampleIdx <- seq(from=1000, to=numSamples, by=100)
samples <- result$samples[sampleIdx,]
sampleLogScores <- result$logScores[sampleIdx,]
mEdgeProb <- getEdgeProbabilities(samples, maxParents, functLogLocalStructureScore, sampleLogScores)
# Plot ROC curve
roc <- getRocCurve(mEdgeProb, mAdj)
xy <- matrix(c(0,1,0,1), 2, 2)
plot(roc, type="l", xlim=c(0,1), ylim=c(0,1), col="blue")
lines(xy, col="red")
functNodeStateProb <- createStateProbabilityFunction(cardinalities, mObs, functSuffStats=functSuffStats)
functFamiliesAndLogStructureScores <- function(node, vOrder) {
scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)
}
system.time({
vEstimatedObsProbs <- getStateVectorProbability(mUniqueObs, samples, maxParents, functNodeStateProb, functFamiliesAndLogStructureScores)
})
getKLDivergence(vObsProbs, vEstimatedObsProbs)
training_data <- read.table("~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/training_data.txt", header=T, quote="\"")
View(training_data)
test_data <- read.table("~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/test_data.txt", header=T, quote="\"")
View(test_data)
library("gtools")
library("hash")
library("R.utils")
library("rbenchmark")
library("testthat")
sourceDir <- "~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/functions"
sourceDirectory(sourceDir)
# Data and parameters for MCMC
mObs <- as.matrix(training_data)
varNames <- names(training_data)
numNodes <- length(varNames)
cardinalities <- rep(3, numNodes)
maxParents <- 3
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
training_data <- read.table("~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/training_data.txt", header=T, quote="\"")
View(training_data)
test_data <- read.table("~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/test_data.txt", header=T, quote="\"")
View(test_data)
save.image("~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/training_data_and_test_data.RData")
library("gtools")
library("hash")
library("R.utils")
library("rbenchmark")
library("testthat")
sourceDir <- "~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/functions"
sourceDirectory(sourceDir)
# Data and parameters for MCMC
mObs <- as.matrix(training_data)
varNames <- names(training_data)
numNodes <- length(varNames)
cardinalities <- rep(3, numNodes)
maxParents <- 3
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
# Local structure score function log(score(Xi, Pa(Xi) | D, <))
functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
system.time(scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents))
# Data and parameters for MCMC
mObs <- as.matrix(training_data)
varNames <- names(training_data)
numNodes <- length(varNames)
cardinalities <- rep(3, numNodes)
maxParents <- 3
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
# Local structure score function log(score(Xi, Pa(Xi) | D, <))
functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
system.time(scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents))
# Replace the local structure scoring function with its cached version
functLogLocalStructureScore <- function(node, parents, vOrder) {
scoreList$getFamilyScore(node, parents)
}
# Local order score i.e term of node in log P(D | <)
pruningDiff <- 7 # best family consistent with an order exp(7) times more probable than worst included in computations
functLogLocalOrderScore <- function(node, vOrder) {
getLogSumOfExponentials( scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)$scores )
}
# order-MCMC
numSamples <- 5000
system.time(result <- runOrderMCMC(numNodes, maxParents, functLogLocalOrderScore, numSamples))
plot(rowSums(result$logScores), type="l")
load("~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/training_data_and_test_data.RData")
library("gtools")
library("hash")
library("R.utils")
library("rbenchmark")
library("testthat")
sourceDir <- "~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/functions"
sourceDirectory(sourceDir)
# Data and parameters for MCMC
mObs <- as.matrix(training_data)
varNames <- names(training_data)
numNodes <- length(varNames)
cardinalities <- rep(3, numNodes)
maxParents <- 3
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
# Local structure score function log(score(Xi, Pa(Xi) | D, <))
functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
system.time(scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents))
library("gtools")
library("hash")
library("R.utils")
library("rbenchmark")
library("testthat")
sourceDir <- "~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/functions"
sourceDirectory(sourceDir)
load("~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/training_data_and_test_data.RData")
# Data and parameters for MCMC
mObs <- as.matrix(training_data)
varNames <- names(training_data)
numNodes <- length(varNames)
cardinalities <- rep(3, numNodes)
maxParents <- 3
# Function for sufficient stats
functSuffStats <- createSufficientStatsProvider(cardinalities, mObs)
# Local structure score function log(score(Xi, Pa(Xi) | D, <))
functLogLocalStructureScore <- createLogLocalStructureScoringFunction(cardinalities, maxParents, functSuffStats)
# Cache all the local structure scores
system.time(scoreList <- computeFamilyScores(functLogLocalStructureScore, numNodes, maxParents))
# Replace the local structure scoring function with its cached version
functLogLocalStructureScore <- function(node, parents, vOrder) {
scoreList$getFamilyScore(node, parents)
}
# Local order score i.e term of node in log P(D | <)
pruningDiff <- 7 # best family consistent with an order exp(7) times more probable than worst included in computations
functLogLocalOrderScore <- function(node, vOrder) {
getLogSumOfExponentials( scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)$scores )
}
# order-MCMC
numSamples <- 25000
system.time(result <- runOrderMCMC(numNodes, maxParents, functLogLocalOrderScore, numSamples))
plot(rowSums(result$logScores), type="l")
result$samples[1,]
result$samples[5000:5100,]
result1 <- result
save.image("~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/order_mcmc_training_data_run_1.RData")
load("~/Hommia/Santsaus/Project in Probabilistic Models (582637)/my-r-order-mcmc/order_mcmc_training_data_run_2.RData")
sampleIdx <- seq(from=5000, to=numSamples, by=200)
plot(rowSums(result1$logScores[5000:25000,]), type="l")
sampleIdx <- seq(from=5000, to=numSamples, by=200)
sampleIdx <- seq(from=5000, to=numSamples, by=200)
samples1 <- result1$samples[sampleIdx,]
sampleLogScores1 <- result1$logScores[sampleIdx,]
samples2 <- result2$samples[sampleIdx,]
sampleLogScores2 <- result2$logScores[sampleIdx,]
samples <- rbind(samples1, samples2)
sampleLogScores <- rbind(sampleLogScores1, sampleLogScores2)
# Compute edge probabilities
mEdgeProb <- getEdgeProbabilities(samples, maxParents, functLogLocalStructureScore, sampleLogScores)
mTestObs <- as.matrix(test_data)
# compute the predicted test vector probabilities using all the samples
functNodeStateProb <- createStateProbabilityFunction(cardinalities, mObs, functSuffStats=functSuffStats)
functFamiliesAndLogStructureScores <- function(node, vOrder) {
scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)
}
system.time({
vEstimatedObsProbs <- getStateVectorProbability(mTestObs, samples, maxParents, functNodeStateProb, functFamiliesAndLogStructureScores)
})
# normalize vEstTestObsProbs
vEstTestObsProbsNorm <- vEstTestObsProbs/sum(vEstTestObsProbs)
# compute the predicted test vector probabilities using all the samples
functNodeStateProb <- createStateProbabilityFunction(cardinalities, mObs, functSuffStats=functSuffStats)
functFamiliesAndLogStructureScores <- function(node, vOrder) {
scoreList$getFamiliesAndScores(node, vOrder, pruningDiff)
}
system.time({
vEstimatedObsProbs <- getStateVectorProbability(mTestObs, samples, maxParents, functNodeStateProb, functFamiliesAndLogStructureScores)
})
